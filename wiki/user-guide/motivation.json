{
  "reference": {
    "path": "wiki/user-guide",
    "baseUrl": "https://www.holunda.io/camunda-bpm-data",
    "fileName": "motivation",
    "extension": "html",
    "usePrettyUrl": true,
    "link": "https://www.holunda.io/camunda-bpm-data/wiki/user-guide/motivation"
  },
  "next": {
    "path": "wiki/user-guide",
    "baseUrl": "https://www.holunda.io/camunda-bpm-data",
    "fileName": "features",
    "extension": "html",
    "usePrettyUrl": true,
    "link": "https://www.holunda.io/camunda-bpm-data/wiki/user-guide/features"
  },
  "data": {"title": "Motivation"},
  "description": "",
  "title": "Motivation",
  "content": "<div class=\"sect1\">\n<h2 id=\"_motivation\">Motivation<\/h2>\n<div class=\"sectionbody\">\n<div class=\"sect2\">\n<h3 id=\"_typed_access_to_process_variables\">Typed access to process variables<\/h3>\n<div class=\"paragraph\">\n<p>Camunda BPM engine provide Java API to access the process variables.\nThis consists of:<\/p>\n<\/div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>RuntimeService<\/code> methods<\/p>\n<\/li>\n<li>\n<p><code>TaskService<\/code> methods<\/p>\n<\/li>\n<li>\n<p>Methods on <code>DelegateExecution<\/code><\/p>\n<\/li>\n<li>\n<p>Methods on <code>DelegateTask<\/code><\/p>\n<\/li>\n<li>\n<p><code>VariableMap<\/code><\/p>\n<\/li>\n<\/ul>\n<\/div>\n<div class=\"paragraph\">\n<p>All those methods requires the user of the API to know the variable type.\nHere is a usage example:<\/p>\n<\/div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">ProcessInstance processInstance = ...;\nList&lt;OrderPosition&gt; orderPositions = (List&lt;OrderPosition&gt;) runtimeService\n  .getVariable(processInstance.id, \"orderPositions\");<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"paragraph\">\n<p>This leads to problems during refactoring and makes variable access more complicated than it is. This library addresses\nthis issue and allows for more convenient type-safe process variable access.<\/p>\n<\/div>\n<div class=\"paragraph\">\n<p>More details can be found in:<\/p>\n<\/div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><a href=\"https://medium.com/holisticon-consultants/data-in-process-part-1-2620bf9abd76\">Data in Process (Part 1)<\/a><\/p>\n<\/li>\n<li>\n<p><a href=\"https://medium.com/holisticon-consultants/data-in-process-part-2-7c6a109e6ee2\">Data in Process (Part 2)<\/a><\/p>\n<\/li>\n<\/ul>\n<\/div>\n<\/div>\n<div class=\"sect2\">\n<h3 id=\"_variable_guards\">Variable guards<\/h3>\n<div class=\"paragraph\">\n<p>Process automation often follows strict rules defined by the business. On the other hand, the process execution itself\ndefines rules in terms of pre- and post-conditions on the process payload (stored as process variables in Camunda BPM).\nRising complexity of the implemented processes makes the compliance to those rules challenging. In order to fulfill the\nconditions on process variables during the execution of business processes, a concept of <code>VariableGuard<\/code> is provided by\nthe library. A guard consists of a set of <code>VariableConditions<\/code> and can be evaluated in all contexts, the variables\nare used in: <code>DelegateTask<\/code>, <code>DelegateExecution<\/code>, <code>TaskService<\/code>, <code>RuntimeService<\/code>, <code>VariableMap<\/code>.<\/p>\n<\/div>\n<div class=\"paragraph\">\n<p>Here is an example of a task listener verifying that a process variable <code>ORDER_APPROVED<\/code> is set, which\nwill throw a <code>GuardViolationException<\/code> if the condition is not met.<\/p>\n<\/div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">import static io.holunda.camunda.bpm.data.guard.CamundaBpmDataGuards.exists;\n\n@Component\nclass MyGuardListener extends DefaultGuardTaskListener {\n\n    public MyGuardListener() {\n        super(newArrayList(exists(ORDER_APPROVED)), true);\n    }\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<\/div>\n<div class=\"sect2\">\n<h3 id=\"_anti_corruption_layer\">Anti-Corruption-Layer<\/h3>\n<div class=\"paragraph\">\n<p>If a process is signalled or hit by a correlated message, there is no way to check if the transported variables are set correctly.\nIn addition, the variables are written directly to the execution of the correlated process instance. In case of a multi-instance\nevent-base sub-process this will eventually overwrite the values of the main execution.<\/p>\n<\/div>\n<div class=\"paragraph\">\n<p>To prevent all this, a feature called Anti-Corruption-Layer (ACL) is implemented. An ACL is there to protect the execution\nfrom bad modifications and influence the way, the modification is executed. For the protection, an ACL relies on a Variables Guards,\ndefining conditions to be satisfied. For the influencing of modification, the <code>VariableMapTransformer<\/code> can be used.<\/p>\n<\/div>\n<div class=\"paragraph\">\n<p>To use the ACL layer you will need to change the way you correlate messages (or signal the execution). Instead of supplying the variables\ndirectly to the <code>correlate<\/code> method of the <code>RuntimeService<\/code>, the client is wrapping all variables into a map hold by a single transient variable\nand correlate this variable with the process (we call this procedure variable wrapping). On the process side, an execution listener placed\non the end of the catch event is responsible to extract the variable map from the transient variable, check it by passing through the <code>VariablesGuard<\/code>\nand finally pass over to the <code>VariableMapTransformer<\/code> to map from external to internal representation.<\/p>\n<\/div>\n<div class=\"paragraph\">\n<p>Here is the code, required on the client side to correlate the message.<\/p>\n<\/div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Component\nclass SomeService {\n\n    private static AntiCorruptionLayer MY_ACL = CamundaBpmDataACL.guardTransformingReplace(\n        \"__transient\", // name of the transient variable for wrapping\n        true, // if passes the guard, write to local scope\n        new VariablesGuard(exists(ORDER_ID)), // guard defining condition on ORDER_ID\n        IdentityVariableMapTransformer.INSTANCE // use 1:1 transformer\n                                                // write the variables without modifications\n    );\n\n    public void correlate() {\n        VariableMap variables = CamundaBpmData.builder()\n          .set(ORDER_ID, \"4711\")\n          .set(ORDER_APPROVED, false)\n          .build();\n        runtimeService.correlateMessage(\"message_1\", MESSAGE_ACL.checkAndWrap(variables));\n    }\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"paragraph\">\n<p>On the process side, the BPMN message catch event should have an <code>End<\/code> listener responsible for unwrapping the values. If the listener is\nimplemented as a Spring Bean bounded via delegate expression <code>${messageAclListener}<\/code> then the following code is responsible for providing such a listener:<\/p>\n<\/div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">@Configuration\nclass SomeConfiguration {\n\n    private static AntiCorruptionLayer MY_ACL = CamundaBpmDataACL.guardTransformingReplace(\n        \"__transient\", // name of the transient variable for wrapping\n        true, // if passes the guard, write to local scope\n        new VariablesGuard(exists(ORDER_ID)), // guard defining condition on ORDER_ID\n        IdentityVariableMapTransformer.INSTANCE // use 1:1 transformer\n                                                // write the variables without modifications\n    );\n\n    @Bean(\"messageAclListener\")\n    public ExecutionListener messageAclListener() {\n        return MY_ACL.getExecutionListener();\n    }\n}<\/code><\/pre>\n<\/div>\n<\/div>\n<div class=\"paragraph\">\n<p>Such a setup will only allow to correlate messages, if the variables provided include a value for the <code>ORDER_ID<\/code>. It will write all\nvariables provided (<code>ORDER_ID<\/code> and <code>ORDER_APPROVED<\/code>) into a local scope of the execution.<\/p>\n<\/div>\n<\/div>\n<\/div>\n<\/div>"
}